<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Labirynt Matematyczny 0–30</title>
  <style>
    :root {
      --cell-size: 44px;
      --border: #b8bcc2;
      --empty: transparent;
      --filled: #ffffff;
      --accent: #2a7de1;
      --good: #17723f;
      --bad: #b21c1c;
    }

    body {
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      background: #ffffff;
      margin: 0;
      padding: 0;
      color: #1d1d1f;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 24px 24px 12px;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 26px;
    }

    p {
      margin: 0 0 10px;
      line-height: 1.5;
    }

    .status {
      font-weight: 600;
      margin-top: 6px;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .maze-wrapper {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px 24px 24px;
    }

    .maze {
      display: grid;
      grid-template-rows: repeat(var(--rows), var(--cell-size));
      grid-template-columns: repeat(var(--cols), var(--cell-size));
      gap: 0;
    }

    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      border: 2px solid var(--border);
      background: var(--filled);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: calc(var(--cell-size) * 0.45);
      font-weight: 600;
      color: #202227;
      box-sizing: border-box;
    }

    .cell.empty {
      border-color: transparent;
      background: var(--empty);
    }

    .cell input {
      width: 100%;
      height: 100%;
      border: none;
      background: transparent;
      text-align: center;
      font-size: calc(var(--cell-size) * 0.42);
      font-weight: 700;
      color: #202227;
      outline: none;
      cursor: pointer;
    }

    .cell.correct {
      background: rgba(23, 114, 63, 0.1);
      border-color: var(--good);
    }

    .cell.incorrect {
      background: rgba(178, 28, 28, 0.1);
      border-color: var(--bad);
    }

    .legend {
      font-size: 14px;
      color: #555;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      margin-top: 12px;
    }

    .maze-button {
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 10px 16px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 8px 16px rgba(42, 125, 225, 0.2);
    }

    .maze-button:hover {
      background: #1c6bcc;
    }

    .coin {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: 999px;
      background: #f7f0d5;
      color: #7c5b00;
      font-weight: 700;
      border: 2px solid #d1a12d;
    }

    .coin-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ffe59a, #e2b23b);
      border: 2px solid #b88215;
      display: grid;
      place-items: center;
      font-size: 14px;
      color: #6d4b00;
      font-weight: 800;
    }
  </style>
</head>
<body>
  <header>
    <h1>Mnożenie i dzielenie w zakresie 0–30</h1>
    <p>Wstaw brakujące liczby, aby równania w labiryncie były prawdziwe. Kliknij pole i wpisz liczbę.</p>
    <div class="controls">
      <button class="maze-button" id="newMaze">Nowy labirynt</button>
      <div class="status" id="status"></div>
    </div>
    <div class="legend">Zakres liczb: 0–30</div>
  </header>

  <section class="maze-wrapper">
    <div class="maze" id="maze"></div>
  </section>

  <script>
    const mazeElement = document.getElementById("maze");
    const statusElement = document.getElementById("status");
    const newMazeButton = document.getElementById("newMaze");

    const rows = 13;
    const cols = 17;
    document.documentElement.style.setProperty("--rows", rows);
    document.documentElement.style.setProperty("--cols", cols);

    const placementCount = 11;
    const equationLength = 5;
    let lastLayoutSignature = null;

    const inputs = [];

    const buildEmptyGrid = () =>
      Array.from({ length: rows }, () => Array.from({ length: cols }, () => null));

    const setCell = (grid, row, col, cell) => {
      grid[row][col] = cell;
    };

    const placeHorizontal = (grid, row, colStart, items) => {
      items.forEach((item, index) => setCell(grid, row, colStart + index, item));
    };

    const placeVertical = (grid, rowStart, col, items) => {
      items.forEach((item, index) => setCell(grid, rowStart + index, col, item));
    };

    const inputCell = (answer) => ({ type: "input", answer: String(answer) });

    const randomPick = (items) => items[Math.floor(Math.random() * items.length)];

    const generateLayoutPlacements = () => {
      const buildSignature = (placements) =>
        placements.map((placement) => `${placement.direction}:${placement.row}:${placement.col}`).join("|");

      const isWithinBounds = (row, col) => row >= 0 && row < rows && col >= 0 && col < cols;

      const getCellsForPlacement = (placement) => {
        const cells = [];
        for (let index = 0; index < equationLength; index += 1) {
          const row = placement.direction === "horizontal" ? placement.row : placement.row + index;
          const col = placement.direction === "horizontal" ? placement.col + index : placement.col;
          cells.push({ row, col });
        }
        return cells;
      };

      const hasAdjacentConnection = (cells, occupied) =>
        cells.some(({ row, col }) => {
          const neighbors = [
            { row: row - 1, col },
            { row: row + 1, col },
            { row, col: col - 1 },
            { row, col: col + 1 }
          ];
          return neighbors.some(
            (neighbor) => isWithinBounds(neighbor.row, neighbor.col) && occupied[neighbor.row][neighbor.col]
          );
        });

      for (let attempt = 0; attempt < 50; attempt += 1) {
        const occupied = buildEmptyGrid().map((row) => row.map(() => false));
        const placements = [];

        for (let index = 0; index < placementCount; index += 1) {
          let placed = false;
          for (let tries = 0; tries < 200; tries += 1) {
            const direction = Math.random() > 0.5 ? "horizontal" : "vertical";
            const maxRow = direction === "horizontal" ? rows - 1 : rows - equationLength;
            const maxCol = direction === "horizontal" ? cols - equationLength : cols - 1;
            const row = Math.floor(Math.random() * (maxRow + 1));
            const col = Math.floor(Math.random() * (maxCol + 1));
            const placement = { direction, row, col };
            const cells = getCellsForPlacement(placement);

            if (cells.some(({ row: cellRow, col: cellCol }) => occupied[cellRow][cellCol])) {
              continue;
            }

            if (index > 0 && !hasAdjacentConnection(cells, occupied)) {
              continue;
            }

            cells.forEach(({ row: cellRow, col: cellCol }) => {
              occupied[cellRow][cellCol] = true;
            });
            placements.push(placement);
            placed = true;
            break;
          }

          if (!placed) {
            break;
          }
        }

        if (placements.length === placementCount) {
          const signature = buildSignature(placements);
          if (signature !== lastLayoutSignature) {
            lastLayoutSignature = signature;
            return placements;
          }
        }
      }

      return [];
    };

    const multiplicationPairs = [];
    for (let a = 1; a <= 10; a += 1) {
      for (let b = 1; b <= 10; b += 1) {
        const product = a * b;
        if (product <= 30) {
          multiplicationPairs.push({ a, b, c: product });
        }
      }
    }

    const createMultiplicationEquation = () => {
      const { a, b, c } = randomPick(multiplicationPairs);
      const missing = randomPick(["a", "b", "c"]);
      if (missing === "a") {
        return [inputCell(a), "·", String(b), "=", String(c)];
      }
      if (missing === "b") {
        return [String(a), "·", inputCell(b), "=", String(c)];
      }
      return [String(a), "·", String(b), "=", inputCell(c)];
    };

    const createDivisionEquation = () => {
      const { a: divisor, b: quotient, c: dividend } = randomPick(multiplicationPairs);
      const missing = randomPick(["dividend", "divisor", "quotient"]);
      if (missing === "dividend") {
        return [inputCell(dividend), ":", String(divisor), "=", String(quotient)];
      }
      if (missing === "divisor") {
        return [String(dividend), ":", inputCell(divisor), "=", String(quotient)];
      }
      return [String(dividend), ":", String(divisor), "=", inputCell(quotient)];
    };

    const createEquation = () => {
      const choice = Math.random() > 0.5 ? "multiply" : "divide";
      return choice === "multiply" ? createMultiplicationEquation() : createDivisionEquation();
    };

    const buildGrid = () => {
      const grid = buildEmptyGrid();
      let layoutPlacements = generateLayoutPlacements();
      while (layoutPlacements.length === 0) {
        layoutPlacements = generateLayoutPlacements();
      }
      layoutPlacements.forEach((placement) => {
        const equation = createEquation();
        if (placement.direction === "horizontal") {
          placeHorizontal(grid, placement.row, placement.col, equation);
        } else {
          placeVertical(grid, placement.row, placement.col, equation);
        }
      });
      return grid;
    };

    function renderGrid(grid) {
      mazeElement.innerHTML = "";
      inputs.length = 0;
      grid.forEach((row) => {
        row.forEach((cell) => {
          const cellElement = document.createElement("div");
          cellElement.className = "cell";

          if (!cell) {
            cellElement.classList.add("empty");
            mazeElement.appendChild(cellElement);
            return;
          }

          if (typeof cell === "string") {
            cellElement.textContent = cell;
          } else if (cell.type === "input") {
            const input = document.createElement("input");
            input.setAttribute("inputmode", "numeric");
            input.setAttribute("maxlength", "2");
            input.dataset.answer = cell.answer;
            input.addEventListener("input", () => validateInput(input, cellElement));
            input.addEventListener("focus", () => input.select());
            cellElement.appendChild(input);
            inputs.push(input);
          }

          mazeElement.appendChild(cellElement);
        });
      });
    }

    function validateInput(input, cellElement) {
      const value = input.value.trim();
      const answer = input.dataset.answer;
      cellElement.classList.remove("correct", "incorrect");
      if (!value) {
        updateStatus();
        return;
      }
      if (value === answer) {
        cellElement.classList.add("correct");
      } else {
        cellElement.classList.add("incorrect");
      }
      updateStatus();
    }

    function updateStatus() {
      const correct = inputs.filter((input) => input.value.trim() === input.dataset.answer);
      statusElement.innerHTML = `Poprawne: ${correct.length} / ${inputs.length}`;
      if (inputs.length && correct.length === inputs.length) {
        const coin = document.createElement("span");
        coin.className = "coin";
        coin.innerHTML = '<span class="coin-icon">1 zł</span> Brawo! Zdobywasz monetę.';
        statusElement.appendChild(coin);
      }
    }

    function updateCellSize() {
      const availableWidth = window.innerWidth - 48;
      const availableHeight = window.innerHeight - 170;
      const size = Math.floor(Math.min(availableWidth / cols, availableHeight / rows));
      const cellSize = Math.max(24, size);
      document.documentElement.style.setProperty("--cell-size", `${cellSize}px`);
    }

    window.addEventListener("resize", updateCellSize);
    updateCellSize();

    const generateMaze = () => {
      const grid = buildGrid();
      renderGrid(grid);
      updateStatus();
    };

    newMazeButton.addEventListener("click", generateMaze);
    generateMaze();
  </script>
</body>
</html>
